// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

use crate::runner::{Context, Script, ScriptStep};

use camino::Utf8Path;
use indicatif::{MultiProgress, ProgressBar, ProgressStyle};

const PROGRESS_TICK_INTERVAL: std::time::Duration =
    std::time::Duration::from_millis(100);

pub enum Mode {
    Interactive,
    NonInteractive,
}

/// Describes UI-related functionality that's available to each step in a
/// running script.
pub trait Ui {
    /// Tells the UI that the current step is running a substep described by the
    /// supplied string.
    fn set_substep(&self, substep: &str);

    /// Obtains a handle to the log file to which to write the `stdout` output
    /// of a process with the supplied name.
    fn child_stdout(&self, process_name: &str)
        -> anyhow::Result<std::fs::File>;

    /// Obtains a handle to the log file to which to write the `stderr` output
    /// of a process with the supplied name.
    fn child_stderr(&self, process_name: &str)
        -> anyhow::Result<std::fs::File>;
}

/// The handler used to display updates about the status of a particular step or
/// substep.
#[derive(Clone)]
enum StepHandler<'a> {
    ProgressBar(&'a ProgressBar),
    Stdout,
}

impl StepHandler<'_> {
    /// Informs this handler that `step` completed with outcome `result`.
    fn apply_result(&self, step: &ScriptStep, result: &anyhow::Result<()>) {
        match self {
            StepHandler::ProgressBar(bar) => {
                match result {
                    Ok(()) => {
                        bar.set_message(step.label());
                        bar.set_style(
                            ProgressStyle::with_template("✓ {msg:.green}")
                                .unwrap(),
                        );
                    }
                    Err(_) => {
                        bar.set_style(
                            ProgressStyle::with_template("⚠ {msg:.bold.red}")
                                .unwrap(),
                        );
                    }
                }
                bar.finish();
            }
            StepHandler::Stdout => match result {
                Ok(()) => println!("Completed: {}", step.label()),
                Err(e) => {
                    println!("Failed: {}", step.label());
                    println!("  {e:?}");
                }
            },
        }
    }
}

/// Contains the information and references needed to implement [`Ui`] for a
/// specific step in a script.
struct PerStepUi<'a> {
    step_id: usize,
    step: &'a ScriptStep,
    step_handler: StepHandler<'a>,
    log_dir: &'a Utf8Path,
}

impl Ui for PerStepUi<'_> {
    fn set_substep(&self, substep: &str) {
        match self.step_handler {
            StepHandler::ProgressBar(bar) => {
                bar.set_message(format!("{}: {}", self.step.label(), substep));
            }
            StepHandler::Stdout => {
                println!("  {}", substep);
            }
        }
    }

    fn child_stdout(
        &self,
        process_name: &str,
    ) -> anyhow::Result<std::fs::File> {
        self.create_log_file_for_process(LogStream::Stdout, process_name)
    }

    fn child_stderr(
        &self,
        process_name: &str,
    ) -> anyhow::Result<std::fs::File> {
        self.create_log_file_for_process(LogStream::Stderr, process_name)
    }
}

impl PerStepUi<'_> {
    /// Creates a log file for the process named `process_name`.
    ///
    /// Note that the log file is always truncated, not appended to. The
    /// framework adds a step ID to each log file name to disambiguate output
    /// files generated by the same process name in different steps, but if the
    /// same step needs to run a single process multiple times, it should tag
    /// them with distinct `process_name`s.
    fn create_log_file_for_process(
        &self,
        stream: LogStream,
        process_name: &str,
    ) -> anyhow::Result<std::fs::File> {
        let mut path = self.log_dir.to_path_buf();
        path.push(format!("{}.{}.{}.log", self.step_id, process_name, stream));
        Ok(std::fs::File::create(&path)?)
    }
}

pub fn run_script(
    script: Box<dyn Script>,
    mut ctx: Context,
    log_dir: &Utf8Path,
    mode: Mode,
) -> anyhow::Result<()> {
    let (_multi, bars) = match mode {
        Mode::Interactive => {
            let multi = MultiProgress::new();
            let bars: Vec<ProgressBar> = script
                .steps()
                .iter()
                .map(|step| {
                    let bar = multi.add(ProgressBar::new_spinner());
                    bar.set_message(step.label());
                    bar.set_style(
                        ProgressStyle::with_template("  {msg:.dim}").unwrap(),
                    );
                    bar.tick();
                    bar
                })
                .collect();

            (Some(multi), Some(bars))
        }
        Mode::NonInteractive => (None, None),
    };

    let substep_handlers: Box<dyn Iterator<Item = StepHandler>> = match &bars {
        Some(bars) => Box::new(bars.iter().map(StepHandler::ProgressBar)),
        None => Box::new(std::iter::repeat(StepHandler::Stdout)),
    };

    for (step_number, (step, handler)) in
        script.steps().iter().zip(substep_handlers).enumerate()
    {
        let ui = PerStepUi {
            step_id: step_number,
            step,
            step_handler: handler,
            log_dir,
        };

        if let StepHandler::ProgressBar(bar) = ui.step_handler {
            bar.set_style(ProgressStyle::default_spinner());
            bar.enable_steady_tick(PROGRESS_TICK_INTERVAL);
        }

        let result = step.run(&mut ctx, &ui);
        ui.step_handler.apply_result(step, &result);
        result?;
    }

    Ok(())
}

enum LogStream {
    Stdout,
    Stderr,
}

impl std::fmt::Display for LogStream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                Self::Stdout => "stdio",
                Self::Stderr => "stderr",
            }
        )
    }
}
